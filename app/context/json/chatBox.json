{
    "chatBox.js: ": "\n        \n        ```\n\n        export function ChatBox() {\n          const [messages, setMessages] = useState([\n            { sender: \"assistant\", text: \"Hey ðŸ‘‹ -- What do you want to know about?\" },\n          ])\n          const [inputText, setInputText] = useState(\"\")\n          const [isLoading, setIsLoading] = useState(false)\n        \n          const handleSendMessage = useCallback(async () => {\n            if (inputText.trim() !== \"\" && !isLoading) {\n              setIsLoading(true)\n              setInputText(\"\")\n        \n              const userMessage = { sender: \"user\", text: inputText.trim() }\n              const assistantMessage = { sender: \"assistant\", text: \"\" }\n        \n              setMessages([...messages, userMessage, assistantMessage])\n        \n              // Extract assistant and user messages\n              const userMessages = messages\n                .filter((msg) => msg.sender === \"user\")\n                .map((msg) => msg.text)\n              userMessages.push(inputText.trim()) // include the new user message\n              const assistantMessages = messages\n                .filter((msg) => msg.sender === \"assistant\")\n                .map((msg) => msg.text)\n        \n              try {\n                let currentStreamedText = \"\"\n                await fetchEventSource(\"http://localhost:5005/api/v1/assistant/completion\", {\n                method: \"POST\",\n                body: JSON.stringify({\n                  userMessage: inputText.trim(),\n                  a: JSON.stringify(assistantMessages),\n                  u: JSON.stringify(userMessages),\n                  llm: 35\n                }),\n                headers: { \"Content-Type\": \"application/json\" },\n                // onopen() {\n                //   console.log(\"Connection opened\");\n                // },\n                onmessage(ev) {\n                  if (ev.data) {\n                    currentStreamedText += JSON.parse(ev.data)\n                  }\n        \n                  setMessages((prevMessages) => {\n                    const newMessages = [...prevMessages]\n                    const lastMessageIndex = newMessages.length - 1\n        \n                    newMessages[lastMessageIndex] = {\n                      ...newMessages[lastMessageIndex],\n                      text: currentStreamedText,\n                    }\n        \n                    return newMessages\n                  })\n                  setIsLoading(false)\n                  return false // tell fetchEventSource not to expect a response for this message\n                },\n                onerror(err) {\n                  console.error(\"EventSource failed:\", err)\n                  setIsLoading(false)\n                },\n                async onclose() {\n                  setMessages((prevMessages) => {\n                    const newMessages = [...prevMessages]\n                    const lastMessageIndex = newMessages.length - 1\n        \n                    newMessages[lastMessageIndex] = {\n                      ...newMessages[lastMessageIndex],\n                      text: currentStreamedText,\n                    }\n        \n                    return newMessages\n                  })\n                  setIsLoading(false)\n                  console.log(\"Connection closed\");\n                },\n              })\n        \n              } catch (error) {\n                console.error(\"Error:\", error)\n                setIsLoading(false)\n              }\n            }\n          }, [inputText, isLoading, messages, oaiKey])\n        \n          const handleKeyDown = (event) => {\n            if (event.key === \"Enter\" && !event.shiftKey) {\n              handleSendMessage()\n              event.preventDefault()\n            }\n          }\n        \n          const scrollAreaRef = useRef(null)\n        \n          useEffect(() => {\n            if (!isLoading && scrollAreaRef.current) {\n              scrollAreaRef.current.scrollHeight + 4000\n              scrollAreaRef.current.scrollIntoView({ behavior: \"smooth\" });\n              \n            }\n          }, [messages, isLoading])\n        \n          useEffect(() => {\n            if (isLoading && scrollAreaRef.current) {\n              scrollAreaRef.current.scrollIntoView({ behavior: \"smooth\" })\n            }\n          }, [messages, isLoading])\n        \n         // Please provide a fictional character who represents a talented developer who utilized his skills to build an arbitrage tool and achieve great entrepreneurial success. I need creative, yet realistic illustrations of how a developer can bootstrap their way to success. \n        \n        \n          return (\n            <section>\n              <ChatWindow messages={messages} scrollAreaRef={scrollAreaRef} isLoading={isLoading} />\n              { isLoading ? '' : <MessageInput\n                isDisabled={false}\n                isLoading={isLoading}\n                inputText={inputText}\n                handleKeyDown={handleKeyDown}\n                handleSendMessage={handleSendMessage}\n                setInputText={setInputText}\n              />}\n            </section>\n          )\n        }\n        \n        ```\n        \n        "
  }